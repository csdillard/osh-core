/***************************** BEGIN LICENSE BLOCK ***************************

The contents of this file are subject to the Mozilla Public License, v. 2.0.
If a copy of the MPL was not distributed with this file, You can obtain one
at http://mozilla.org/MPL/2.0/.

Software distributed under the License is distributed on an "AS IS" basis,
WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
for the specific language governing rights and limitations under the License.

Copyright (C) 2019 Sensia Software LLC. All Rights Reserved.

******************************* END LICENSE BLOCK ***************************/

package org.sensorhub.impl.procedure;

import java.lang.ref.WeakReference;
import java.time.Instant;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import org.sensorhub.api.data.ICommandReceiver;
import org.sensorhub.api.data.IDataProducer;
import org.sensorhub.api.data.IStreamingControlInterface;
import org.sensorhub.api.data.IStreamingDataInterface;
import org.sensorhub.api.datastore.feature.FeatureKey;
import org.sensorhub.api.event.Event;
import org.sensorhub.api.event.IEventListener;
import org.sensorhub.api.feature.FeatureId;
import org.sensorhub.api.obs.DataStreamAddedEvent;
import org.sensorhub.api.obs.DataStreamChangedEvent;
import org.sensorhub.api.procedure.IProcedureDriver;
import org.sensorhub.api.procedure.IProcedureEventHandlerDatabase;
import org.sensorhub.api.procedure.IProcedureGroupDriver;
import org.sensorhub.api.procedure.ProcedureEvent;
import org.sensorhub.api.procedure.ProcedureId;
import org.sensorhub.api.utils.OshAsserts;
import org.vast.ogc.gml.IGeoFeature;
import org.vast.ogc.gml.ITemporalFeature;
import org.vast.util.Asserts;


/**
 * Helper class for handling events generated by procedure drivers and
 * persisting any data or metadata updates to a 
 * {@link IProcedureEventHandlerDatabase}
 *
 * @author Alex Robin
 * @date Nov 18, 2020
 */
public class ProcedureEventPersistenceHandler implements IEventListener
{
    protected final WeakReference<IProcedureEventHandlerDatabase> dbRef; // reference to handling database
    protected WeakReference<IProcedureDriver> driverRef; // reference to live procedure

    protected String procUID;
    protected ProcedureId procID;
    
    protected Map<String, DataStreamEventPersistenceHandler> dataStreamListeners = new ConcurrentHashMap<>();
    protected Map<String, ProcedureEventPersistenceHandler> memberListeners = new ConcurrentHashMap<>();
    protected Map<String, FeatureId> fois = new ConcurrentHashMap<>();
    

    public ProcedureEventPersistenceHandler(IProcedureDriver proc, IProcedureEventHandlerDatabase db)
    {
        this.procUID = Asserts.checkNotNull(proc.getUniqueIdentifier());
        this.dbRef = new WeakReference<>(Asserts.checkNotNull(db, IProcedureEventHandlerDatabase.class));
        this.driverRef = new WeakReference<>(Asserts.checkNotNull(proc, IProcedureDriver.class));
    }


    public void connectLiveProcedure(IProcedureDriver proc)
    {
        this.driverRef = new WeakReference<>(Asserts.checkNotNull(proc, IProcedureDriver.class));
        DefaultProcedureRegistry.log.debug("Procedure {} connected", procUID);
    }


    public void disconnectLiveProcedure(IProcedureDriver proc)
    {
        proc.unregisterListener(this);
        driverRef.clear();
        DefaultProcedureRegistry.log.debug("Procedure {} disconnected", procUID);
    }
    
    
    protected CompletableFuture<Boolean> register(IProcedureDriver proc)
    {
        Asserts.checkNotNull(proc, IProcedureDriver.class);
        OshAsserts.checkValidUID(proc.getUniqueIdentifier());
        
        return CompletableFuture.supplyAsync(() -> {
            return doRegister(proc);
        });
    }
    
    
    protected boolean doRegister(IProcedureDriver proc)
    {
        return doRegister(0L, proc);
    }
    
    
    protected boolean doRegister(long parentID, IProcedureDriver proc)
    {
        var db = getDatabase();
        FeatureKey procKey = db.getProcedureStore().getCurrentVersionKey(procUID);
        boolean isNew = procKey == null;
        
        // need to make sure we add things if they are missing in storage            
        // store data source description if none was found
        if (procKey == null)
            procKey = db.getProcedureStore().add(parentID, proc.getCurrentDescription());
        
        // otherwise update to the latest sensor description in case we were down during the last update
        else if (proc.getLastDescriptionUpdate() != Long.MIN_VALUE)
        {
            Instant validStartTime = proc.getCurrentDescription().getValidTime().begin();
            if (procKey.getValidStartTime().isBefore(validStartTime))
                procKey = db.getProcedureStore().add(parentID, proc.getCurrentDescription());
        }
        
        this.procID = new ProcedureId(procKey.getInternalID(), procUID);
        if (proc.isEnabled())
            proc.registerListener(this);
        
        // if data producer, register fois and datastreams
        if (proc instanceof IDataProducer)
        {
            var dataSource = (IDataProducer)proc;
            
            for (var foi: dataSource.getCurrentFeaturesOfInterest().values())
                doRegister(foi);
            
            for (var dataStream: dataSource.getOutputs().values())
                doRegister(dataStream);
        }
        
        // if command sink, register control streams
        if (proc instanceof ICommandReceiver)
        {
            var taskableSource = (ICommandReceiver)proc;
            for (var controlStream: taskableSource.getCommandInputs().values())
                doRegister(controlStream);            
        }
        
        // if group, also register members recursively
        if (proc instanceof IProcedureGroupDriver)
        {
            for (var member: ((IProcedureGroupDriver<?>)proc).getMembers().values())
                doRegisterMember(this, member);
        }
        
        return isNew;
    }
    
    
    protected boolean doRegisterMember(ProcedureEventPersistenceHandler parentHandler, IProcedureDriver proc)
    {
        Asserts.checkNotNull(proc, IProcedureDriver.class);
        OshAsserts.checkValidUID(proc.getUniqueIdentifier());
        
        var proxy = memberListeners.compute(proc.getUniqueIdentifier(), (k,v) -> {
            if (v == null)
                v = createMemberHandler(proc);
            return v;
        });
        
        return proxy.doRegister(parentHandler.procID.getInternalID(), proc);
    }


    protected CompletableFuture<Void> unregister(IProcedureDriver proc)
    {
        Asserts.checkNotNull(proc, IProcedureDriver.class);
        
        unregisterListener(proc);        
        return CompletableFuture.completedFuture(null);
    }
    
    
    private void unregisterListener(IProcedureDriver proc)
    {
        proc.unregisterListener(this);
    }


    protected CompletableFuture<Boolean> register(IStreamingDataInterface dataStream)
    {
        Asserts.checkNotNull(dataStream, IStreamingDataInterface.class);
        
        return CompletableFuture.supplyAsync(() -> {
            return doRegister(dataStream);
        });
    }
    
    
    protected boolean doRegister(IStreamingDataInterface dataStream)
    {
        var dsHandler = dataStreamListeners.computeIfAbsent(dataStream.getName(), k -> {
            return createDataStreamHandler(dataStream);
        });
        
        return dsHandler.register(dataStream);
    }


    protected CompletableFuture<Void> unregister(IStreamingDataInterface dataStream)
    {
        Asserts.checkNotNull(dataStream, IStreamingDataInterface.class);
        
        unregisterListener(dataStream);        
        return CompletableFuture.completedFuture(null);
    }
    
    
    private void unregisterListener(IStreamingDataInterface dataStream)
    {
        var listener = dataStreamListeners.remove(dataStream.getName());
        if (listener != null)
            dataStream.unregisterListener(listener);
    }


    protected CompletableFuture<Boolean> register(IStreamingControlInterface controlStream)
    {
        Asserts.checkNotNull(controlStream, IStreamingControlInterface.class);
        
        return CompletableFuture.supplyAsync(() -> {
            return doRegister(controlStream);
        });
    }
    
    
    protected boolean doRegister(IStreamingControlInterface controlStream)
    {
        throw new UnsupportedOperationException("Control streams not implemented yet");
    }


    protected CompletableFuture<Void> unregister(IStreamingControlInterface controlStream)
    {
        throw new UnsupportedOperationException("Control streams not implemented yet");
    }


    protected CompletableFuture<Boolean> register(IGeoFeature foi)
    {
        Asserts.checkNotNull(foi, IGeoFeature.class);
        OshAsserts.checkValidUID(foi.getUniqueIdentifier());
        
        return CompletableFuture.supplyAsync(() -> {
            return doRegister(foi);
        });
    }
    
    
    protected boolean doRegister(IGeoFeature foi)
    {
        var db = getDatabase();
        var uid = foi.getUniqueIdentifier();
        boolean isNew = true;
        
        FeatureKey fk = db.getFoiStore().getCurrentVersionKey(uid);
        
        // store feature description if none was found
        if (fk == null)
            fk = db.getFoiStore().add(foi);
        
        // otherwise add it only if its newer than the one already in storage
        else
        {
            var validTime = foi instanceof ITemporalFeature ? ((ITemporalFeature)foi).getValidTime() : null;
            if (validTime != null && fk.getValidStartTime().isBefore(validTime.begin()))
                fk = db.getFoiStore().add(foi);
            else
                isNew = false;            
        }
        
        fois.put(uid, new FeatureId(fk.getInternalID(), uid));
        return isNew;
    }


    @Override
    public void handleEvent(Event e)
    {
        if (e instanceof ProcedureEvent)
        {
            // register item if needed
            var proc = driverRef.get();
            if (proc != null && proc.isEnabled())
            {
                if (proc instanceof IDataProducer)
                {
                    var outputs = ((IDataProducer)proc).getOutputs();
                    
                    if (e instanceof DataStreamAddedEvent || e instanceof DataStreamChangedEvent)
                        register(outputs.get(((DataStreamAddedEvent)e).getOutputName()));
                    else if (e instanceof DataStreamAddedEvent)
                        register(outputs.get(((DataStreamAddedEvent)e).getOutputName()));
                    // TODO handle all event types and redirect to register methods when appropriate
                }
            }
        }
    }
    
    
    protected ProcedureEventPersistenceHandler createMemberHandler(IProcedureDriver childProc)
    {
        var parent = this;
        return new ProcedureEventPersistenceHandler(childProc, getDatabase()) {
            @Override
            protected IProcedureEventHandlerDatabase getDatabase()
            {
                return parent.getDatabase();
            }
        };
    }
    
    
    protected DataStreamEventPersistenceHandler createDataStreamHandler(IStreamingDataInterface dataStream)
    {
        return new DataStreamEventPersistenceHandler(this);
    }
    
    
    protected IProcedureEventHandlerDatabase getDatabase()
    {
        return dbRef.get();
    }
}
