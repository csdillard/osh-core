/***************************** BEGIN LICENSE BLOCK ***************************

The contents of this file are subject to the Mozilla Public License, v. 2.0.
If a copy of the MPL was not distributed with this file, You can obtain one
at http://mozilla.org/MPL/2.0/.

Software distributed under the License is distributed on an "AS IS" basis,
WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
for the specific language governing rights and limitations under the License.

Copyright (C) 2019 Sensia Software LLC. All Rights Reserved.

******************************* END LICENSE BLOCK ***************************/

package org.sensorhub.impl.procedure;

import java.lang.ref.WeakReference;
import java.time.Instant;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionException;
import java.util.concurrent.ConcurrentHashMap;
import org.sensorhub.api.data.ICommandReceiver;
import org.sensorhub.api.data.IDataProducer;
import org.sensorhub.api.data.IStreamingControlInterface;
import org.sensorhub.api.data.IStreamingDataInterface;
import org.sensorhub.api.datastore.DataStoreException;
import org.sensorhub.api.datastore.feature.FeatureKey;
import org.sensorhub.api.event.Event;
import org.sensorhub.api.event.IEventListener;
import org.sensorhub.api.feature.FeatureId;
import org.sensorhub.api.obs.DataStreamAddedEvent;
import org.sensorhub.api.obs.DataStreamChangedEvent;
import org.sensorhub.api.procedure.IProcedureDriver;
import org.sensorhub.api.procedure.IProcedureEventHandlerDatabase;
import org.sensorhub.api.procedure.IProcedureGroupDriver;
import org.sensorhub.api.procedure.ProcedureEvent;
import org.sensorhub.api.procedure.ProcedureId;
import org.sensorhub.api.utils.OshAsserts;
import org.vast.ogc.gml.IGeoFeature;
import org.vast.ogc.gml.ITemporalFeature;
import org.vast.util.Asserts;


/**
 * Helper class for handling events generated by procedure drivers and
 * persisting any data or metadata updates to a 
 * {@link IProcedureEventHandlerDatabase}
 *
 * @author Alex Robin
 * @date Nov 18, 2020
 */
public class ProcedureEventPersistenceHandler implements IEventListener
{
    protected final WeakReference<IProcedureEventHandlerDatabase> dbRef; // reference to handling database
    protected WeakReference<IProcedureDriver> driverRef; // reference to live procedure

    protected String procUID;
    protected ProcedureId procID;
    
    protected Map<String, DataStreamEventPersistenceHandler> dataStreamListeners = new ConcurrentHashMap<>();
    protected Map<String, ProcedureEventPersistenceHandler> memberListeners = new ConcurrentHashMap<>();
    protected Map<String, FeatureId> fois = new ConcurrentHashMap<>();
    

    public ProcedureEventPersistenceHandler(IProcedureDriver proc, IProcedureEventHandlerDatabase db)
    {
        this.procUID = Asserts.checkNotNull(proc.getUniqueIdentifier());
        this.dbRef = new WeakReference<>(Asserts.checkNotNull(db, IProcedureEventHandlerDatabase.class));
    }
    
    
    protected CompletableFuture<Boolean> connect(IProcedureDriver proc)
    {
        Asserts.checkNotNull(proc, IProcedureDriver.class);
        OshAsserts.checkValidUID(proc.getUniqueIdentifier());
        
        return CompletableFuture.supplyAsync(() -> {
            try { return doRegister(proc); }
            catch (DataStoreException e) { throw new CompletionException(e); }
        });
    }
    
    
    protected boolean doRegister(IProcedureDriver proc) throws DataStoreException
    {
        this.driverRef = new WeakReference<>(Asserts.checkNotNull(proc, IProcedureDriver.class));
        return doRegister(0L, proc);
    }
    
    
    protected boolean doRegister(long parentID, IProcedureDriver proc) throws DataStoreException
    {
        var db = getDatabase();
        FeatureKey procKey = db.getProcedureStore().getCurrentVersionKey(procUID);
        boolean isNew = procKey == null;
        
        // need to make sure we add things if they are missing in storage            
        // store data source description if none was found
        if (procKey == null)
            procKey = db.getProcedureStore().add(parentID, proc.getCurrentDescription());
        
        // otherwise update to the latest sensor description in case we were down during the last update
        else if (proc.getLastDescriptionUpdate() != Long.MIN_VALUE)
        {
            Instant validStartTime = proc.getCurrentDescription().getValidTime().begin();
            if (procKey.getValidStartTime().isBefore(validStartTime))
                procKey = db.getProcedureStore().add(parentID, proc.getCurrentDescription());
        }
        
        this.procID = new ProcedureId(procKey.getInternalID(), procUID);
        if (proc.isEnabled())
            DefaultProcedureRegistry.log.debug("Procedure {} connected", procUID);
        proc.registerListener(this);
        
        // if data producer, register fois and datastreams
        if (proc instanceof IDataProducer)
        {
            var dataSource = (IDataProducer)proc;
            
            for (var foi: dataSource.getCurrentFeaturesOfInterest().values())
                doRegister(foi);
            
            for (var dataStream: dataSource.getOutputs().values())
                doRegister(dataStream);
        }
        
        // if command sink, register command streams
        if (proc instanceof ICommandReceiver)
        {
            var taskableSource = (ICommandReceiver)proc;
            for (var commanStream: taskableSource.getCommandInputs().values())
                doRegister(commanStream);            
        }
        
        // if group, also register members recursively
        if (proc instanceof IProcedureGroupDriver)
        {
            for (var member: ((IProcedureGroupDriver<?>)proc).getMembers().values())
                doRegisterMember(member);
        }        

        if (DefaultProcedureRegistry.log.isDebugEnabled())
        {
            DefaultProcedureRegistry.log.debug(
                String.format("Procedure %s registered (%d FOIs, %d datastreams, %d command inputs, %d members)",
                    procUID,
                    proc instanceof IDataProducer ? ((IDataProducer)proc).getCurrentFeaturesOfInterest().size() : 0,
                    proc instanceof IDataProducer ? ((IDataProducer)proc).getOutputs().size() : 0,
                    proc instanceof ICommandReceiver ? ((ICommandReceiver)proc).getCommandInputs().size() : 0,
                    proc instanceof IProcedureGroupDriver ? ((IProcedureGroupDriver<?>)proc).getMembers().size() : 0)
            );
        }
        
        return isNew;
    }
    
    
    protected boolean doRegisterMember(IProcedureDriver proc) throws DataStoreException
    {
        Asserts.checkNotNull(proc, IProcedureDriver.class);
        OshAsserts.checkValidUID(proc.getUniqueIdentifier());
        
        var proxy = memberListeners.compute(proc.getUniqueIdentifier(), (k,v) -> {
            if (v == null)
                v = createMemberProcedureHandler(proc);
            return v;
        });
        
        return proxy.doRegister(procID.getInternalID(), proc);
    }


    protected CompletableFuture<Void> unregister(IProcedureDriver proc)
    {
        Asserts.checkNotNull(proc, IProcedureDriver.class);
        
        doUnregister(proc);      
        return CompletableFuture.completedFuture(null);
    }
    
    
    protected void doUnregister(IProcedureDriver proc)
    {
        proc.unregisterListener(this);
        driverRef.clear();
        DefaultProcedureRegistry.log.debug("Procedure {} disconnected", procUID);
        
        // if data producer, unregister datastreams
        if (proc instanceof IDataProducer)
        {
            var dataSource = (IDataProducer)proc;
            for (var dataStream: dataSource.getOutputs().values())
                doUnregister(dataStream);
        }
        
        // if command sink, unregister command streams
        if (proc instanceof ICommandReceiver)
        {
            var taskableSource = (ICommandReceiver)proc;
            for (var commanStream: taskableSource.getCommandInputs().values())
                doUnregister(commanStream);            
        }
        
        // if group, also unregister members recursively
        if (proc instanceof IProcedureGroupDriver)
        {
            for (var member: ((IProcedureGroupDriver<?>)proc).getMembers().values())
                doUnregister(member);
        }
    }


    protected CompletableFuture<Boolean> register(IStreamingDataInterface dataStream)
    {
        Asserts.checkNotNull(dataStream, IStreamingDataInterface.class);
        
        return CompletableFuture.supplyAsync(() -> {
            try { return doRegister(dataStream); }
            catch (DataStoreException e) { throw new CompletionException(e); }
        });
    }
    
    
    protected boolean doRegister(IStreamingDataInterface dataStream) throws DataStoreException
    {
        var dsHandler = dataStreamListeners.computeIfAbsent(dataStream.getName(), k -> {
            return createDataStreamHandler(dataStream);
        });
        
        return dsHandler.connect(dataStream);
    }


    protected CompletableFuture<Void> unregister(IStreamingDataInterface dataStream)
    {
        Asserts.checkNotNull(dataStream, IStreamingDataInterface.class);
        doUnregister(dataStream);
        return CompletableFuture.completedFuture(null);
    }
    
    
    protected void doUnregister(IStreamingDataInterface dataStream)
    {
        var dsHandler = dataStreamListeners.remove(dataStream.getName());
        if (dsHandler != null)
            dsHandler.unregister(dataStream);
    }


    protected CompletableFuture<Boolean> register(IStreamingControlInterface controlStream)
    {
        Asserts.checkNotNull(controlStream, IStreamingControlInterface.class);
        
        return CompletableFuture.supplyAsync(() -> {
            return doRegister(controlStream);
        });
    }
    
    
    protected boolean doRegister(IStreamingControlInterface commandStream)
    {
        DefaultProcedureRegistry.log.warn("Command streams register not implemented yet");
        return true;
    }


    protected CompletableFuture<Void> unregister(IStreamingControlInterface commandStream)
    {
        Asserts.checkNotNull(commandStream, IStreamingControlInterface.class);
        doUnregister(commandStream);
        return CompletableFuture.completedFuture(null);
    }
    
    
    protected void doUnregister(IStreamingControlInterface proc)
    {
        DefaultProcedureRegistry.log.warn("Command streams unregister not implemented yet");
    }


    protected CompletableFuture<Boolean> register(IGeoFeature foi)
    {
        Asserts.checkNotNull(foi, IGeoFeature.class);
        OshAsserts.checkValidUID(foi.getUniqueIdentifier());
        
        return CompletableFuture.supplyAsync(() -> {
            try { return doRegister(foi); }
            catch (DataStoreException e) { throw new CompletionException(e); }
        });
    }
    
    
    protected boolean doRegister(IGeoFeature foi) throws DataStoreException
    {
        var db = getDatabase();
        var uid = foi.getUniqueIdentifier();
        boolean isNew = true;
        
        FeatureKey fk = db.getFoiStore().getCurrentVersionKey(uid);
        
        // store feature description if none was found
        if (fk == null)
            fk = db.getFoiStore().add(foi);
        
        // otherwise add it only if its newer than the one already in storage
        else
        {
            var validTime = foi instanceof ITemporalFeature ? ((ITemporalFeature)foi).getValidTime() : null;
            if (validTime != null && fk.getValidStartTime().isBefore(validTime.begin()))
                fk = db.getFoiStore().add(foi);
            else
                isNew = false;            
        }
        
        fois.put(uid, new FeatureId(fk.getInternalID(), uid));
        return isNew;
    }


    @Override
    public void handleEvent(Event e)
    {
        if (e instanceof ProcedureEvent)
        {
            // register item if needed
            var proc = driverRef.get();
            if (proc != null && proc.isEnabled())
            {
                if (proc instanceof IDataProducer)
                {
                    var outputs = ((IDataProducer)proc).getOutputs();
                    
                    if (e instanceof DataStreamAddedEvent || e instanceof DataStreamChangedEvent)
                        register(outputs.get(((DataStreamAddedEvent)e).getOutputName()));
                    else if (e instanceof DataStreamAddedEvent)
                        register(outputs.get(((DataStreamAddedEvent)e).getOutputName()));
                    // TODO handle all event types and redirect to register methods when appropriate
                }
            }
        }
    }
    
    
    protected ProcedureEventPersistenceHandler createMemberProcedureHandler(IProcedureDriver childProc)
    {
        var parent = this;
        return new ProcedureEventPersistenceHandler(childProc, getDatabase()) {
            @Override
            protected IProcedureEventHandlerDatabase getDatabase()
            {
                return parent.getDatabase();
            }
        };
    }
    
    
    protected DataStreamEventPersistenceHandler createDataStreamHandler(IStreamingDataInterface dataStream)
    {
        return new DataStreamEventPersistenceHandler(this);
    }
    
    
    protected IProcedureEventHandlerDatabase getDatabase()
    {
        return dbRef.get();
    }
}
