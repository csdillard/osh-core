/***************************** BEGIN LICENSE BLOCK ***************************

The contents of this file are subject to the Mozilla Public License, v. 2.0.
If a copy of the MPL was not distributed with this file, You can obtain one
at http://mozilla.org/MPL/2.0/.

Software distributed under the License is distributed on an "AS IS" basis,
WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
for the specific language governing rights and limitations under the License.

Copyright (C) 2020 Sensia Software LLC. All Rights Reserved.

******************************* END LICENSE BLOCK ***************************/

package org.sensorhub.impl.procedure;

import java.time.Instant;
import java.util.concurrent.CompletableFuture;
import org.sensorhub.api.data.FoiEvent;
import org.sensorhub.api.data.IStreamingControlInterface;
import org.sensorhub.api.data.IStreamingDataInterface;
import org.sensorhub.api.datastore.DataStoreException;
import org.sensorhub.api.event.Event;
import org.sensorhub.api.event.IEventPublisher;
import org.sensorhub.api.obs.DataStreamAddedEvent;
import org.sensorhub.api.obs.DataStreamDisabledEvent;
import org.sensorhub.api.obs.DataStreamEnabledEvent;
import org.sensorhub.api.procedure.IProcedureDriver;
import org.sensorhub.api.procedure.IProcedureEventHandlerDatabase;
import org.sensorhub.api.procedure.ProcedureAddedEvent;
import org.sensorhub.api.procedure.ProcedureChangedEvent;
import org.sensorhub.api.procedure.ProcedureDisabledEvent;
import org.sensorhub.api.procedure.ProcedureEnabledEvent;
import org.sensorhub.api.task.CommandStreamAddedEvent;
import org.sensorhub.api.task.CommandStreamDisabledEvent;
import org.sensorhub.api.task.CommandStreamEnabledEvent;
import org.vast.ogc.gml.IGeoFeature;
import org.vast.util.Asserts;


/**
 * Helper class of {@link DefaultProcedureRegistry} responsible for handling
 * events generated by procedure drivers. It takes care of persisting data or
 * metadata to the proper database and forwarding events to the event bus.
 *
 * @author Alex Robin
 * @date Nov 18, 2020
 */
public class ProcedureRegistryEventHandler extends ProcedureEventPersistenceHandler
{
    protected final DefaultProcedureRegistry registry;
    protected IEventPublisher eventPublisher;    
    protected long latestDescriptionUpdate = Long.MIN_VALUE;
    
    
    public ProcedureRegistryEventHandler(DefaultProcedureRegistry registry, IProcedureDriver proc, IProcedureEventHandlerDatabase db)
    {
        super(proc, db);
        this.registry = Asserts.checkNotNull(registry, DefaultProcedureRegistry.class);
    }
    
    
    protected IEventPublisher getParentPublisher(IProcedureDriver proc)
    {
        // if adding to a parent group, publish event to parent group channel
        if (proc.getParentGroupUID() != null)
            return registry.getDriverHandler(proc.getParentGroupUID()).eventPublisher;
        
        // else publish in registry channel
        else       
            return registry.getParentHub().getEventPublisher();
    }
    
    
    @Override
    protected boolean doRegister(long parentID, IProcedureDriver proc) throws DataStoreException
    {
        var saveLastUpdated = latestDescriptionUpdate;
        
        // connect to event bus if needed
        if (eventPublisher == null)
        {
            var eventSrcInfo = proc.getEventSourceInfo();
            eventPublisher = registry.getParentHub().getEventBus().getPublisher(eventSrcInfo);
        }            
        
        // register procedure
        boolean isNew = super.doRegister(parentID, proc);
        latestDescriptionUpdate = proc.getLastDescriptionUpdate();
        
        // send ProcedureAdded or ProcedureEnabled event depending if
        // procedure was registered before or not
        var newProcEvent = isNew ? 
            new ProcedureAddedEvent(
                System.currentTimeMillis(),
                procUID,
                proc.getParentGroupUID()) :
            new ProcedureEnabledEvent(
                System.currentTimeMillis(),
                procUID,
                proc.getParentGroupUID());
        getParentPublisher(proc).publish(newProcEvent);
        
        // also send procedure changed event if description has changed
        // TODO check if it has actually changed?
        if (saveLastUpdated < latestDescriptionUpdate)
        {
            eventPublisher.publish(new ProcedureChangedEvent(System.currentTimeMillis(), procUID));
        }
        
        return isNew;
    }


    @Override
    public CompletableFuture<Void> unregister(IProcedureDriver proc)
    {
        return super.unregister(proc).thenRun(() -> {
            getParentPublisher(proc).publish(new ProcedureDisabledEvent(
                procUID,
                proc.getParentGroupUID()));
        });
    }


    @Override
    protected boolean doRegister(IStreamingDataInterface dataStream) throws DataStoreException
    {
        boolean isNew = super.doRegister(dataStream);
        
        // send event if datastream wasn't registered before
        if (isNew)
        {
            eventPublisher.publish(new DataStreamAddedEvent(
                procUID,
                dataStream.getName()));
        }
        
        // else send enabled event   
        else
        {
            eventPublisher.publish(new DataStreamEnabledEvent(
                procUID, 
                dataStream.getName()));
        }
        
        return isNew;
    }


    @Override
    protected void doUnregister(IStreamingDataInterface dataStream)
    {
        super.doUnregister(dataStream);
        
        eventPublisher.publish(new DataStreamDisabledEvent(
            procUID,
            dataStream.getName()));
    }


    @Override
    protected boolean doRegister(IStreamingControlInterface commandStream)
    {
        boolean isNew = super.doRegister(commandStream);
        
        // send event if command stream wasn't registered before
        if (isNew)
        {
            eventPublisher.publish(new CommandStreamAddedEvent(
                procUID,
                commandStream.getName()));
        }
        
        // else send enabled event   
        else
        {
            eventPublisher.publish(new CommandStreamEnabledEvent(
                procUID, 
                commandStream.getName()));
        }
        
        return isNew;
    }


    @Override
    public void doUnregister(IStreamingControlInterface commandStream)
    {
        super.doUnregister(commandStream);
        
        eventPublisher.publish(new CommandStreamDisabledEvent(
            procUID,
            commandStream.getName()));
    }


    @Override
    protected boolean doRegister(IGeoFeature foi) throws DataStoreException
    {
        boolean isNew = super.doRegister(foi);
        
        if (isNew)
        {
            eventPublisher.publish(new FoiEvent(
                System.currentTimeMillis(),
                procUID,
                foi.getUniqueIdentifier(),
                Instant.now()));
        }
        
        return isNew;
    }
    
    
    protected IProcedureEventHandlerDatabase getDatabase()
    {
        // try to get associated database
        // default to procedure state database if DB has been turned off
        var db = dbRef.get();
        return db != null ? db : (IProcedureEventHandlerDatabase)registry.getProcedureStateDatabase();
    }
    
    
    protected ProcedureRegistryEventHandler createMemberProcedureHandler(IProcedureDriver childProc)
    {
        var parent = this;
        return new ProcedureRegistryEventHandler(registry, childProc, getDatabase()) {
            @Override
            protected IProcedureEventHandlerDatabase getDatabase()
            {
                return parent.getDatabase();
            }
        };
    }
    
    
    protected DataStreamEventPersistenceHandler createDataStreamHandler(IStreamingDataInterface dataStream)
    {
        var eventSrcInfo = dataStream.getEventSourceInfo();
        var eventPublisher = registry.getParentHub().getEventBus().getPublisher(eventSrcInfo);
        
        return new DataStreamEventPersistenceHandler(this) {            
            @Override
            public void handleEvent(Event e)
            {
                // first forward to event bus to minimize latency
                eventPublisher.publish(e);                
                super.handleEvent(e);
            }
        };
    }
}
